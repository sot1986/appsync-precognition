import{baseErrors,cleanString,date,datetime,email,getHeader,getNestedValue,integer,isArray,numeric,parseErrorMessage,phone,setNestedValue,time,ulid,url,uuid}from"./utils.js";import{runtime,util}from"@aws-appsync/utils";function parse(c,O){const[M,...N]=typeof O===`string`?[O,void 0]:isArray(O)?[O[0],...O.slice(1)]:typeof O.rule===`string`?[O.rule,void 0]:[O.rule[0],...O.rule.slice(1)];switch(M){case`required`:return requiredRule(c);case`nullable`:return nullableRule(c);case`sometimes`:return sometimesRule(c);case`min`:case`bigger`:return betweenRule(c,N[0],void 0,M===`bigger`);case`max`:case`lower`:return betweenRule(c,void 0,N[0],M===`lower`);case`between`:case`within`:return betweenRule(c,N[0],N[1],M===`within`);case`regex`:return regexRule(c,...N);case`in`:return inRule(c,...N);case`notIn`:return notInRule(c,...N);case`before`:case`beforeOrEqual`:return beforeRule(c,N[0],M===`before`);case`after`:case`afterOrEqual`:return afterRule(c,N[0],M===`after`);case`email`:return regexRule({...c,msg:c.msg??c.errors.email},email);case`phone`:return regexRule({...c,msg:c.msg??c.errors.phone},phone);case`url`:return regexRule({...c,msg:c.msg??c.errors.url},url);case`uuid`:return regexRule({...c,msg:c.msg??c.errors.uuid},uuid);case`ulid`:return regexRule({...c,msg:c.msg??c.errors.ulid},ulid);case`integer`:return regexRule({...c,msg:c.msg??c.errors.integer},integer);case`date`:return regexRule({...c,msg:c.msg??c.errors.date},date);case`time`:return regexRule({...c,msg:c.msg??c.errors.time},time);case`datetime`:return regexRule({...c,msg:c.msg??c.errors.datetime},datetime);case`numeric`:return regexRule({...c,msg:c.msg??c.errors.numeric},numeric);default:return typeRule(c,M)}}function betweenRule({value:c,msg:O,errors:k},A=-Infinity,j=Infinity,M=false){const[N,P]=[j===Infinity,A===-Infinity];const I={check:false,msg:O??N?M?k.biggerNumber:k.minNumber:P?M?k.lowerNumber:k.maxNumber:M?k.withinNumber:k.betweenNumber,value:c,params:{":min":`${A}`,":max":`${j}`}};if(typeof c===`number`)I.check=M?c>A&&c<j:c>=A&&c<=j;if(typeof c===`string`){I.check=c.length>=A&&c.length<=j;I.msg=O??N?k.minString:P?k.maxString:k.betweenString}if(isArray(c)){I.check=c.length>=A&&c.length<=j;I.msg=O??N?k.minArray:P?k.maxArray:k.betweenArray}return I}function regexRule({value:c,msg:O,errors:k},...A){const j={check:false,msg:O??(A.length===1?k.regex:k.regex_patterns),value:c,params:A.length===1?{":pattern":A[0]}:{":patterns":A.join(`, `)}};if(typeof c===`string`)j.check=A.some(O=>util.matches(O,c));if(typeof c===`number`)j.check=A.some(O=>util.matches(O,`${c}`));return j}function inRule({value:c,msg:O,errors:k},...A){return{check:A.includes(c),msg:O??k.in,value:c,params:{":in":A.join(`, `)}}}function notInRule({value:c,msg:O,errors:k},...A){return{check:!A.includes(c),msg:O??k.notIn,value:c,params:{":notIn":A.join(`, `)}}}function requiredRule({value:c,msg:O,errors:k}){const A={check:true,msg:O??k.required,value:c,skipNext:true};if(typeof c===`string`)A.check=c.length>0;if(isArray(c))A.check=c.length>0;if(typeof c===`number`)A.check=true;if(typeof c===`boolean`)A.check=true;if(typeof c===`object`&&!A.value)A.check=false;if(typeof c===`undefined`)A.check=false;A.skipNext=!A.check;return A}function nullableRule({value:c,msg:O,errors:k}){return{check:true,msg:O??k.nullable,value:c,skipNext:typeof c===`undefined`||c===null}}function sometimesRule({value:c,msg:O,errors:k}){const A={check:true,msg:O??k.sometimes,value:c};if(typeof c===`undefined`){A.skipNext=true;return A}if(typeof c===`object`&&!A.value){A.check=false;A.skipNext=true;return A}return requiredRule({value:c,msg:O,errors:k})}function typeRule({value:c,msg:O,errors:k},A){const j={check:false,msg:O??k.type,value:c,params:{":type":A}};switch(A){case`array`:j.check=isArray(c);break;case`object`:j.check=typeof c===`object`&&!!c&&!isArray(c)&&Object.keys(c).length>0;break;case`boolean`:j.check=typeof c===`boolean`;break;case`number`:j.check=typeof c===`number`;break;default:j.check=typeof c===`string`}return j}function beforeRule({value:c,msg:O,errors:k},A,j=false){const M={check:false,msg:O??k.before,value:c,params:j?{":before":A}:{":beforeOrEqual":A}};const N=util.time.parseISO8601ToEpochMilliSeconds(A);const P=typeof c===`string`?util.time.parseISO8601ToEpochMilliSeconds(c):c;if(typeof P===`number`)M.check=j?P<N:P<=N;return M}function afterRule({value:c,msg:O,errors:k},A,j=false){const M={check:false,msg:O??j?k.after:k.afterOrEqual,value:c,params:j?{":after":A}:{":afterOrEqual":A}};const N=util.time.parseISO8601ToEpochMilliSeconds(A);const P=typeof c===`string`?util.time.parseISO8601ToEpochMilliSeconds(c):c;if(typeof P===`number`)M.check=j?P>N:P>=N;return M}function isRule(c){return typeof c===`object`&&!!c&&Object.hasOwn(c,`check`)}function isCustomFullRule(c){return typeof c===`object`&&!!c&&Object.hasOwn(c,`rule`)}function validate(k,A,j){let M={};const P={...baseErrors,...j?.errors};Object.keys(A).forEach(c=>{const O=c.split(`.`);O.forEach((j,M)=>{if(j!==`*`||M===0)return;const P=getNestedValue(k,O.slice(0,M).join(`.`));if(!isArray(P))return;P.forEach((k,j)=>{const N=[...O];N[M]=`${j}`;A[N.join(`.`)]=A[c]});delete A[c]})});Object.keys(A).forEach(c=>{let F=getNestedValue(k,c);if(typeof F===`string`){F=cleanString(F,j);setNestedValue(k,c,F)}let I=false;A[c]?.forEach(O=>{if(I)return;const k=isRule(O)?{...O,value:F,msg:O.msg??P.invalid}:isCustomFullRule(O)?parse({value:F,msg:O.msg,errors:P},O.rule):parse({value:F,errors:P},O);I=!!k.skipNext||!k.check;if(k.check)return;if(M.msg)util.appendError(M.msg,M.errorType,M.data,M.errorInfo);k.params=k.params??{};if(util.matches(`:attr`,k.msg))k.params[`:attr`]=j?.attributes?.[`:${c}`]??formatAttributeName(c);M={msg:parseErrorMessage(k.msg,k.params),errorType:`ValidationError`,data:null,errorInfo:{path:c,value:F}}})});if(!M.msg)return k;util.error(M.msg,M.errorType,M.data,M.errorInfo)}function precognitiveValidation(c,O,k){const{errors:A,attributes:j}=isLocalized(c)?{errors:{...c.stash.__i18n.errors,...k?.errors},attributes:{...c.stash.__i18n.attributes,...k?.attributes}}:{errors:k?.errors,attributes:k?.attributes};if(getHeader(`precognition`,c)!==`true`){c.stash.__validated=validate(c.args,O,{...k,errors:A,attributes:j});return c.stash.__validated}const N=getHeader(`Precognition-Validate-Only`,c)?.split(`,`).map(c=>c.trim());util.http.addResponseHeader(`Precognition`,`true`);if(!N){c.stash.__validated=validate(c.args,O,{...k,errors:A,attributes:j});util.http.addResponseHeader(`Precognition-Success`,`true`);runtime.earlyReturn(null)}util.http.addResponseHeader(`Precognition-Validate-Only`,N.join(`,`));const P={};N.forEach(c=>{P[c]=O[c]});c.stash.__validated=validate(c.args,P,{...k,errors:A,attributes:j});util.http.addResponseHeader(`Precognition-Success`,`true`);runtime.earlyReturn(null,{skipTo:k?.skipTo??`END`})}function formatAttributeName(c){return c.split(`.`).reduce((c,O)=>{if(util.matches(`^\\d+$`,O))return c;let k=``;O.split(``).forEach((c,O)=>{if(O!==0&&util.matches(`[A-Z]`,c))k+=` `;k+=c.toLowerCase()});return c?`${c} ${k}`:k},``)}function assertValidated(c){if(Object.hasOwn(c.stash,`__validated`))return;util.error(`Context arguements have not been validated`)}function isLocalized(c){return Object.hasOwn(c.stash,`__i18n`)&&typeof c.stash?.__i18n.locale===`string`}export{assertValidated,formatAttributeName,isLocalized,precognitiveValidation,validate};