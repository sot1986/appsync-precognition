import{baseErrors,cleanString,date,datetime,email,getHeader,getNestedValue,integer,isArray,numeric,parseErrorMessage,phone,setNestedValue,time,ulid,url,uuid}from"./utils.js";import{runtime,util}from"@aws-appsync/utils";function parse(c,D){const[j,...M]=typeof D===`string`?[D,void 0]:isArray(D)?[D[0],...D.slice(1)]:typeof D.rule===`string`?[D.rule,void 0]:[D.rule[0],...D.rule.slice(1)];switch(j){case`required`:return requiredRule(c);case`nullable`:return nullableRule(c);case`sometimes`:return sometimesRule(c);case`min`:case`bigger`:return betweenRule(c,M[0],void 0,j===`bigger`);case`max`:case`lower`:return betweenRule(c,void 0,M[0],j===`lower`);case`between`:case`within`:return betweenRule(c,M[0],M[1],j===`within`);case`regex`:return regexRule(c,...M);case`in`:return inRule(c,...M);case`notIn`:return notInRule(c,...M);case`before`:case`beforeOrEqual`:return beforeRule(c,M[0],j===`before`);case`after`:case`afterOrEqual`:return afterRule(c,M[0],j===`after`);case`email`:return regexRule({...c,msg:c.msg??c.errors.email},email);case`phone`:return regexRule({...c,msg:c.msg??c.errors.phone},phone);case`url`:return regexRule({...c,msg:c.msg??c.errors.url},url);case`uuid`:return regexRule({...c,msg:c.msg??c.errors.uuid},uuid);case`ulid`:return regexRule({...c,msg:c.msg??c.errors.ulid},ulid);case`integer`:return regexRule({...c,msg:c.msg??c.errors.integer},integer);case`date`:return regexRule({...c,msg:c.msg??c.errors.date},date);case`time`:return regexRule({...c,msg:c.msg??c.errors.time},time);case`datetime`:return regexRule({...c,msg:c.msg??c.errors.datetime},datetime);case`numeric`:return regexRule({...c,msg:c.msg??c.errors.numeric},numeric);default:return typeRule(c,j)}}function betweenRule({value:c,msg:D,errors:O},k=-Infinity,A=Infinity,j=false){const[M,N]=[k===-Infinity,A===Infinity];const F={check:false,msg:D??M?j?O.biggerNumber:O.minNumber:N?j?O.lowerNumber:O.maxNumber:j?O.withinNumber:O.betweenNumber,value:c};if(typeof c===`number`)F.check=j?c>k&&c<A:c>=k&&c<=A;if(typeof c===`string`){F.check=c.length>=k&&c.length<=A;F.msg=D??M?O.minString:N?O.maxString:O.betweenString}if(isArray(c)){F.check=c.length>=k&&c.length<=A;F.msg=D??M?O.minArray:N?O.maxArray:O.betweenArray}return F}function regexRule({value:c,msg:D,errors:O},...k){const A={check:false,msg:D??(k.length===1?O.regex:O.regex_patterns),value:c,params:k.length===1?{":pattern":k[0]}:{":patterns":k.join(`, `)}};if(typeof c===`string`)A.check=k.some(D=>util.matches(D,c));if(typeof c===`number`)A.check=k.some(D=>util.matches(D,`${c}`));return A}function inRule({value:c,msg:D,errors:O},...k){return{check:k.includes(c),msg:D??O.in,value:c,params:{":in":k.join(`, `)}}}function notInRule({value:c,msg:D,errors:O},...k){return{check:!k.includes(c),msg:D??O.notIn,value:c,params:{":notIn":k.join(`, `)}}}function requiredRule({value:c,msg:D,errors:O}){const k={check:true,msg:D??O.required,value:c,skipNext:true};if(typeof c===`string`)k.check=c.length>0;if(isArray(c))k.check=c.length>0;if(typeof c===`number`)k.check=true;if(typeof c===`boolean`)k.check=true;if(typeof c===`object`&&!k.value)k.check=false;if(typeof c===`undefined`)k.check=false;k.skipNext=!k.check;return k}function nullableRule({value:c,msg:D,errors:O}){return{check:true,msg:D??O.nullable,value:c,skipNext:typeof c===`undefined`||c===null}}function sometimesRule({value:c,msg:D,errors:O}){const k={check:true,msg:D??O.sometimes,value:c};if(typeof c===`undefined`){k.skipNext=true;return k}if(typeof c===`object`&&!k.value){k.check=false;k.skipNext=true;return k}return requiredRule({value:c,msg:D,errors:O})}function typeRule({value:c,msg:D,errors:O},k){const A={check:false,msg:D??O.type,value:c,params:{":type":k}};switch(k){case`array`:A.check=isArray(c);break;case`object`:A.check=typeof c===`object`&&!!c&&!isArray(c)&&Object.keys(c).length>0;break;case`boolean`:A.check=typeof c===`boolean`;break;case`number`:A.check=typeof c===`number`;break;default:A.check=typeof c===`string`}return A}function beforeRule({value:c,msg:D,errors:O},k,A=false){const j={check:false,msg:D??O.before,value:c,params:A?{":before":k}:{":beforeOrEqual":k}};const M=util.time.parseISO8601ToEpochMilliSeconds(k);const N=typeof c===`string`?util.time.parseISO8601ToEpochMilliSeconds(c):c;if(typeof N===`number`)j.check=A?N<M:N<=M;return j}function afterRule({value:c,msg:D,errors:O},k,A=false){const j={check:false,msg:D??A?O.after:O.afterOrEqual,value:c,params:A?{":after":k}:{":afterOrEqual":k}};const M=util.time.parseISO8601ToEpochMilliSeconds(k);const N=typeof c===`string`?util.time.parseISO8601ToEpochMilliSeconds(c):c;if(typeof N===`number`)j.check=A?N>M:N>=M;return j}function isRule(c){return typeof c===`object`&&!!c&&Object.hasOwn(c,`check`)}function isCustomFullRule(c){return typeof c===`object`&&!!c&&Object.hasOwn(c,`rule`)}function validate(O,k,A){let j={};const N={...baseErrors,...A?.errors};Object.keys(k).forEach(c=>{const D=c.split(`.`);D.forEach((A,j)=>{if(A!==`*`||j===0)return;const N=getNestedValue(O,D.slice(0,j).join(`.`));if(!isArray(N))return;N.forEach((O,A)=>{const M=[...D];M[j]=`${A}`;k[M.join(`.`)]=k[c]});delete k[c]})});Object.keys(k).forEach(c=>{let P=getNestedValue(O,c);if(typeof P===`string`){P=cleanString(P,A);setNestedValue(O,c,P)}let F=false;k[c]?.forEach(D=>{if(F)return;const O=isRule(D)?{...D,msg:D.msg??N.invalid}:isCustomFullRule(D)?parse({value:P,msg:D.msg,errors:N},D.rule):parse({value:P,errors:N},D);F=!!O.skipNext||!O.check;if(O.check)return;if(j.msg)util.appendError(j.msg,j.errorType,j.data,j.errorInfo);O.params=O.params??{};if(util.matches(`:attr`,O.msg))O.params[`:attr`]=O.params[`:attr`]??formatAttributeName(c);j={msg:parseErrorMessage(O.msg,O.params),errorType:`ValidationError`,data:null,errorInfo:{path:c,value:P}}})});if(!j.msg)return O;util.error(j.msg,j.errorType,j.data,j.errorInfo)}function precognitiveValidation(c,D,O){if(getHeader(`precognition`,c)!==`true`){c.stash.__validated=validate(c.args,D,O);return c.stash.__validated}const k=getHeader(`Precognition-Validate-Only`,c)?.split(`,`).map(c=>c.trim());util.http.addResponseHeader(`Precognition`,`true`);if(!k){c.stash.__validated=validate(c.args,D,O);util.http.addResponseHeader(`Precognition-Success`,`true`);runtime.earlyReturn(null)}util.http.addResponseHeader(`Precognition-Validate-Only`,k.join(`,`));const A={};k.forEach(c=>{A[c]=D[c]});c.stash.__validated=validate(c.args,A,O);util.http.addResponseHeader(`Precognition-Success`,`true`);runtime.earlyReturn(null,{skipTo:O?.skipTo??`END`})}function formatAttributeName(c){return c.split(`.`).reduce((c,D)=>{if(util.matches(`^\\d+$`,D))return c;let O=``;D.split(``).forEach((c,D)=>{if(D!==0&&util.matches(`[A-Z]`,c))O+=` `;O+=c.toLowerCase()});return c?`${c} ${O}`:O},``)}function assertValidated(c){if(Object.hasOwn(c.stash,`__validated`))return;util.error(`Context arguements have not been validated`)}export{assertValidated,formatAttributeName,precognitiveValidation,validate};